# 前言

网址：[Lab2 · GitBook](http://114.117.246.238:4000/lab2.html)

首先思考这个实验要做的工作：
- 符号表维护（对应PPT语义分析）
- 属性维护（对应PPT语法制导）
- IR的生成（对应PPT中间代码）
- 至于运行环境那章PPT是干啥的？没看，不清楚。
注意is_computable属性涉及到常数优化，例：
```
a = 5
b = 3
c = a + b
d = c + 4
```
c和d都是可以求的，这应该就是所谓的常量优化。（估计有坑：浮点数精度问题，注意一下）
# 任务分解
## IR头文件介绍
- ir_operand是操作数类型，记录name和type，有个type的枚举类型。（type被wrap后加上了ident的名字）
- ir_operator是中间代码的操作，有个operator的枚举类型，对应中间代码的操作
- ir_instruction对应中间代码的一条指令，包括operand: op1,op2,des和一个operator。
- ir_function维护`name, returnType, std::vector<Operand> ParameterList,
std::vector<Instruction*> InstVec`,维护一个函数的形参列表，指令顺序，函数名和返回种类
- ir_program.h下面有两个东西：
```
    struct GlobalVal
    {
        ir::Operand val;
        int maxlen = 0;     //为数组长度设计
        GlobalVal(ir::Operand va);
        GlobalVal(ir::Operand va, int len);
    };
    struct Program {
        std::vector<Function> functions;
        std::vector<GlobalVal> globalVal;
        Program();
        void addFunction(const Function& proc);
        std::string draw();
    };
```
其中GlobalVal记录了单个全局变量。

以及，对于全局变量，设置了特殊函数globalFunc，用于初始化内容。

## Analyzer介绍

```
	int tmp_cnt;
    vector<ir::Instruction*> g_init_inst;
    SymbolTable symbol_table;
```

成员变量如上，，，TODO:`tmp_cnt和g_init_inst`干啥不清楚

## 维护符号表
- 先看符号表
先看看符号表的结构：
首先有个STE的数据结构，维护operand（操作数类型）和dimension数组，这个估计是数组的时候有用，且如果为数组，则Ident视为指针。所以实际上，**一个表项就维护dimension，name和type**
随后有个`using map_str_ste = map<string, STE>;`，记在小本本上。
随后有个
```
struct ScopeInfo {
    int cnt;
    string name;
    map_str_ste table;
};

struct SymbolTable{
    vector<ScopeInfo> scope_stack;
    map<std::string,ir::Function*> functions;
    // methods
    void add_scope(Block*);						//进入新作用域时, 向符号表中添加 ScopeInfo, 相当于压栈
	void exit_scope();							//退出时弹栈
	string get_scoped_name(string id) const; 	//输入一个变量名, 返回其在当前作用域下重命名后的名字 (相当于加后缀)
	Operand get_operand(string id) const;		//输入一个变量名, 在符号表中寻找最近的同名变量, 返回对应的 Operand(注													意，此 Operand 的 name 是重命名后的)
	STE get_ste(string id) const;				//输入一个变量名, 在符号表中寻找最近的同名变量, 返回 STE
};
```
- cnt 是作用域在函数中的唯一编号, 代表是函数中出现的第几个作用域

- name 可以用来分辨作用域的类别, 'b' 代表是一个单独嵌套的作用域, 'i' 'e' 'w' 分别代表由 if else while 产生的新作用域（你也可以取你喜欢的名字，只是这样会表意比较清晰）

- table 是一张存放符号的表, {string: STE}, **string 是操作数的原始名称**, 表项 Variable Table Entry(STE), 实际上就是一个 IR 的操作数，即 STE -> Operand, **在 STE 中存放的应该是变量重命名后的名称**

再看SymbolTable，有个Stack不用说，然后有个functions，这个是干啥的？不知道。

再看看符号表要解决的问题：
**问题一：栈式管理如何管理？**
基本思路：STE[0]默认为$global_scope，STE[1]后面就根据block弹栈，具体地，有：

```
FuncDef -> FuncType Ident '(' [FuncFParams] ')' Block
Stmt -> Block
```
留意这两个语法。（思考如何给这两个Block的Scope命名？尤其是Stmt -> Block?

- *（我的想法是对每个Block项，除了维护名字外，还要维护前继关系和层数信息（当前Block处于第几层），而且，我想称FuncDef出现的Block为显式Block，Stmt为隐式Block，便于命名。*
- 为什么这样分？前者应该是函数名，要单独弄个function，后者不需要
- 此外，注意BlockItem之间其实要么以;作分隔（大家写cpp的时候，姑且可以认为一行算一个BlockItem，结尾是分号，或者是一个Scope）
  **问题二：重命名如何解决？作用域问题？**

    - 注意下，这个重命名为什么要重命名，是因为生成中间代码有变量名字，所以如果当前作用域变量名有冲突，则必须重命名。

```
{
    int a = 3;
    {
        int a = 5;
    }
    {
        int a = 6;
    }
}
```
这里，a = 5和a = 6 都重命名为a_block，两个a因为在不同作用域，所以名字一样也没有问题
**问题三：addscope为何接收一个block节点？**
每进入一个Block就放表项，注意重命名问题！

**问题四：符号表到底有什么用？**

查找引用。一张符号表表项就维护dimension，name和type，以及管理重命名。仅此而已。

如果是数组，dimension会用来算偏移量；以及可能的类型转换。

涉及到嵌套Block的引用问题，一是考虑好重命名处理，二是考虑如何查找引用。

## 属性更新

==**我感觉在Lexical词法解析阶段就他妈可以做？试一试。**==

首先学了语法制导对吧？我们看看树上有哪些属性。

### .t

- .t: 记录了一个变量的type和某个表达式/数字的type

这个属性最终从两个地方来：**定义，以及引用**，然后递归更新上来。

### .v

- .v: 一个字符串, 或者是重命名后的变量名, 或者是临时变量名称, 也可以是常数字符串（我寻思也只有Exp和InitVal有这逼属性啊）

我感觉这个跟常数优化有关，如果是常数优化能弄的，那就传常数，否则传变量名？

### .is_computable

- .is_computable: 根据文档，这是用来标识某个节点是否可以进行常量优化。特别提醒一下，这个缺省值为True的情况有ConstExp和Number，其他的均为False。此外，带is_computable的全为Exp节点。
  （官方文档：节点以下子树是否可以化简为常数, 通过该变量, 大部分常数合并可以直接在语法树中自底向上进行传递）

不知道咋回事

### .arr_name

- .arr_name: 一看就是数组的名字

Var_def和Const_def有

### .n

- .n: FuncDef的，目测是函数名，FuncDef的type应该是返回类型

### .op

- .op: UnaryOp的，TokenType类型

### .jump_*ow

- jump_eow
- .jump_bow: 两个贴注释了

```
 // for while & break & continue, we need a vector to remember break & continue instruction
std::set<ir::Instruction*> jump_eow;  // jump to end of while
std::set<ir::Instruction*> jump_bow;  // jump to begin of while
```
该想想这些属性该怎么更新了。尤其是最后一个，想一下这个跟IR生成有什么关系？set存储指针，指针估计永不重复，那么size()可以确定如何跳转。

```
if (cond){
	if (cond2){
	
	}
	else{
	
	}
	if (cond3){
	
	}
}
```

注意Continue和Break

## IR生成TODO

- 本节所指的PPT均为中间代码PPT

毫无疑问，IR需要用到每个节点的属性记录和STE
也是根据文法改写（增加动作）

### 关于全局变量

全局变量在哪里处理？不用特别担心，记住全局变量在STE[0]的位置，以及GlobalVal处理即可，两个地方。出Block后弹出来就行。局部变量，我的想法就是干脆所有的变量直接加block，防止误判。

### 关于IR翻译

是不是从右到左翻译。。。比如赋值，符合递归向下的特征。。。不清楚，先观望。

### 变量定义IR

```
int a, b, c;
float a[3][9][3];
```

没什么好说的，注意指针类型

### 变量赋值IR

#### 简单赋值

涉及指令`mov/fmov target, source`

PPTP9归纳了赋值语句的出现形式

留意类型检查：

```
float a = 3.99
int b = a
```

#### 涉及数组元素的赋值

见P24，这个时候会在符号表放入临时变量

### 算术运算IR

~~没啥好说的~~

太几把恶心了，运算要考虑是Int还是intLiteral，同时有隐式类型转换，偏偏隐式类型转换不接受Literal，还要个临时变量处理！！！

真蠢啊，value都有了凭啥是IntLiteral？临时变量都他妈有了！！

看了下代码，~~addi, subi貌似没卵用~~，因为一般的运算，变量和常数都接收，以及隐式转换，des不接受Literal（cvt和一般运算都是不接受的），

### 逻辑运算IR

见P31，留意短路运算！！！（可能的优化）

1-true 0-false

### 访存与指针运算IR

这部分主要涉及到数组，load & store & alloc & getptr，看中间代码PPT P21页，计算数组位置，下标运算（见P22，P23）

### 类型转化IR

注意赋值和运算中都可能出现，不再赘述

### 调用返回IR

传参相关，Function

### 跳转IR

只涉及到while和if。IR只有个goto和if goto（if没强调），以及\_\_unuse\_\_

P36 回填技术 P46 翻译TODO：看到这里了

注意jump_eow的属性和jump_bow的属性。

很好，注意短路运算P42（每判断一次，试图跳转），这里会有优化哈。

## 三个迷之宏定义是？

```
#define GET_CHILD_PTR(node, type, index) \
    auto node = dynamic_cast<type*>(root->children[index]);\
    assert(node); 
#define ANALYSIS(node, type, index) \
    auto node = dynamic_cast<type*>(root->children[index]); \
    assert(node); \
    analysis##type(node, buffer);
#define COPY_EXP_NODE(from, to) \
    to->is_computable = from->is_computable; \
    to->v = from->v; \
    to->t = from->t;
```

从`COPY_EXP_NODE`可以看出is_computable是可以变的，估计跟常数优化有关，ANALYSIS目测跟构造AST的PARSE类似，而GET_CHILD_PTR...?不懂.jpg


## 综上所述
因为有jump_eow的存在，所以。。肯定是一起来更新咯，属性，符号表和代码生成，肯定一起来

文档更新了，接口给了，那么思路就很明显了：以一个Scope为单位，记录IR！