# 前置知识
看文档2-5章即可

# 常用指令
```bash
sudo service docker start;
# docker run -it -v /mnt/c/Users/15781/Desktop/dasanxia_homework/2-experiement/3-cp/ex3/ex3_wrapping:/coursegrader --name cpEx frankd35/demo:v3 
docker start cpEx;
docker attach cpEx;
```

```bash

# 测试
cd ../test; python3 run.py S;
cd ../build; make;
cd ../build; make; cd ../test; cd ../test; python3 run.py S; python3 score.py S
cd ../build; make; cd ../test; python3 run.py S; python3 score.py S
cd ../build; make; cd ../test; python3 run.py s2; python3 score.py s2
cd ../bin; ./compiler ../test/testcase/function/38_op_priority4.sy -s2 -o output.txt
cd ../bin; ./compiler ../test/testcase/basic/00_main.sy -s2 -o output.s


# debug
cd ../build; make;
cd ../test; python3 run.py S; python3 score.py S;
cd ../bin; ./compiler ../test/testcase/basic/09_func_defn.sy -S -o output.s
cd ../bin; ./compiler ../test/testcase/basic/09_func_defn.sy -s2 -o outputS.txt
cd ../bin; riscv32-unknown-linux-gnu-gcc ../test/testcase/basic/00_main.sy -S
cd ../bin; riscv32-unknown-linux-gnu-gcc output.s ../test/sylib-riscv-linux.a -o test.exe; qemu-riscv32.sh test.exe; echo $?

# 汇编
cd ../cppTest; riscv32-unknown-linux-gnu-gcc test.cpp -S

# 链接生成可执行文件
riscv32-unknown-linux-gnu-gcc test.s ../test/sylib-riscv-linux.a -o test.exe

# 执行可执行文件
qemu-riscv32.sh test.exe
qemu-riscv32.sh test.exe < input.in > output.out

# 汇编执行看返回值一条龙
cd ../cppTest; riscv32-unknown-linux-gnu-gcc test.cpp -S; riscv32-unknown-linux-gnu-gcc test.s ../test/sylib-riscv-linux.a -o test.exe; qemu-riscv32.sh test.exe; echo $?

# (sy): 汇编执行看返回值一条龙
cd ../cppTest; riscv32-unknown-linux-gnu-gcc test.sy -S; riscv32-unknown-linux-gnu-gcc test.s ../test/sylib-riscv-linux.a -o test.exe; qemu-riscv32.sh test.exe; echo $?

# 链接到执行一条龙
cd ../cppTest; riscv32-unknown-linux-gnu-gcc test.s ../test/sylib-riscv-linux.a -o test.exe; qemu-riscv32.sh test.exe; echo $?
```
# RISC-V介绍
RISC-V 选择了小尾端字节序：即数字的高位以字节为单位存放在地址的低位。

## 如何获取PC
当前的 PC 可以通过将 auipc 的 U 立即数字段设置为 0 来获得。对于 x86-32，要想读取 PC，你需要先进行函数调用，（这样子可以将 PC 推入堆栈）;然后被调用的函数可以从堆栈中读取刚被压栈的 PC，最后将 PC 值返回给调用者（需要再弹出堆栈）。因此，或许当前的 PC至少需要 1 个 store，2 个 load 和 2 个跳转！
## 六种类型

## 算术运算与逻辑运算

## 立即数

## 访存指令

## 分支与跳转指令

## 伪指令
P45

## 扩展标准：乘除法
mul, mulh, mulhsu, mulhu

## 扩展标准：浮点数
RV32F 和 RV32D **没有提供浮点分支指令，而是提供了浮点比较指令**，这些根据两个浮点的比较结果将一个整数寄存器设置为 1 或 0：feq.s，feq.d，flt.s，flt.d，fle.s，fle.d。这些指令允许整数分支指令根据浮点数比较指令设置的条件进行分支跳转。
P60 浮点转换指令
## hilo是什么东西
https://github.com/riscv-non-isa/riscv-asm-manual/issues/63
>I know that %hi(symbol) will get the high 20 bits of the symbols' address and then be as a immediate number in RISC-V 32. In short, take the [31:12] bits in RISC-V 32.

即经过观察可以发现%hi和%lo是获取symbol的高20位和低12位地址作为立即数的方式
# 寄存器管理

## fp(s0)和sp
问题来了：栈指针要移动多少？8的倍数？
https://zhuanlan.zhihu.com/p/67193481

# 函数调用
函数调用过程通常分为 6 个阶段。
1. 将参数存储到函数能够访问到的位置；
2. 跳转到函数开始位置（使用 RV32I 的 jal 指令）；
3. 获取函数需要的局部存储资源，按需保存寄存器；
4. 执行函数中的指令；
5. 将返回值存储到调用者能够访问到的位置，恢复寄存器，释放局部存储资源；
6. 返回调用函数的位置（使用 ret 指令）。

如果参数和局部变量太多，在寄存器中存不下，函数的开头会在栈中为函数帧分配空间来存放。（P43）

这也是最后确定的一件事，函数调用的参数会根据fp来确定，从0开始依次为第9个参数，第10个参数。因此，以s0为标准计算偏移的策略是明智的。
## 栈空间管理

## 寄存器管理

### 寄存器保留问题
P42，例子P42
```
func:
	save callee reg
	....
	save caller reg
	call func2
	restore caller reg
	...
	restore callee reg
```

想一下callee和caller是啥情况：

- caller: 调用者保存寄存器，也就是被调用着可以随意用caller寄存器而不加以保存
  
  - 保存时机在调用函数前，恢复时机在调用函数后 
  - 对于子程序来说，caller寄存器可以随意用，只要不调用其他函数的话。但是要记住自己用了哪些，调用函数的时候要保存。
- callee：被调用者保存寄存器，被调用者一旦使用，要先保存再用，然后在退出的时候要还回来

  - 保存时机在进入函数的开头，恢复时机在退出函数前
  - 这一类寄存器子程序不能随便用，如果要用，要先保存再用，典型代表为sp和fp(s0)，至于其他的save reg，用的时候先保存再用，返回的时候一定要恢复！


因此，我们可以总结一个策略：**当前**（退出或刚进入一个函数时都要清零）函数每个寄存器有个标志位，对于：

- caller寄存器：在使用时置flag，在调用函数时查看flag并保存，恢复时查看flag并恢复
- callee寄存器：在使用时置flag，置位的时候先要有store动作，退出函数前查看flag并load回寄存器
- 对于任何寄存器，当前函数没用过就不要管，特殊的是sp，基本上每个函数都会动，特别关注
# 跳转标签的确定

# 优化算法

线性扫描找出活跃变量
找出依赖图，进行指令重排

# 指示段
.text：进入代码段。
.align 2：后续代码按 22 字节对齐。
.globl main：声明全局符号“main”。
.section .rodata：进入只读数据段
.balign 4：数据段按 4 字节对齐。
.string “Hello, %s!\n”：创建空字符结尾的字符串。
.string “world”：创建空字符结尾的字符串。
P48文段说明和地址规范


# 库函数的调用
库函数都编译好了，你只管call就行了，不需要自己实现这些函数。

```cpp
int getint(),
int getch(),
int getarray(int a[]);
float getfloat();
int getfarray(float a[]);
void putint(int a),
void putch(int a),
void putarray(int n,int a[]);
void putfloat(float a);
void putfarray(int n, float a[]);
```


# 关于汇编的文段
## 关于函数调用
必须有.globl main来声明入口。下面给个例子：
```cpp
int fibonacci(int a){
    return a == 1 ? a : a * fibonacci(a - 1);
}
int main(){
    return fibonacci(4);
}
```

```bash
# 注意文中的所有文段删掉都没啥影响，注意.globl一定要有main声明
	.file	"test.cpp"      //源文件
	.option nopic           // csapp讲过，忘了，跟重定位有关
	.text
	.align	1               // 对齐限制，单位为字节
	.globl	_Z9fibonaccii   // 不知道有什么用，删掉没影响，应该是标识这个标签的吧
	.type	_Z9fibonaccii, @function
_Z9fibonaccii:
.LFB0:
	.cfi_startproc
	addi	sp,sp,-32
	.cfi_def_cfa_offset 32
	sw	ra,28(sp)
	sw	s0,24(sp)
	.cfi_offset 1, -4
	.cfi_offset 8, -8
	addi	s0,sp,32
	.cfi_def_cfa 8, 0
	sw	a0,-20(s0)
	lw	a4,-20(s0)
	li	a5,1
	beq	a4,a5,.L2
	lw	a5,-20(s0)
	addi	a5,a5,-1
	mv	a0,a5
	call	_Z9fibonaccii
	mv	a4,a0
	lw	a5,-20(s0)
	mul	a5,a4,a5
	j	.L4
.L2:
	lw	a5,-20(s0)
.L4:
	mv	a0,a5
	lw	ra,28(sp)
	.cfi_restore 1
	lw	s0,24(sp)
	.cfi_restore 8
	.cfi_def_cfa 2, 32
	addi	sp,sp,32
	.cfi_def_cfa_offset 0
	jr	ra
	.cfi_endproc
.LFE0:
	.size	_Z9fibonaccii, .-_Z9fibonaccii
	.align	1
	.globl	main
	.type	main, @function
main:
.LFB1:
	.cfi_startproc
	addi	sp,sp,-16
	.cfi_def_cfa_offset 16
	sw	ra,12(sp)
	sw	s0,8(sp)
	.cfi_offset 1, -4
	.cfi_offset 8, -8
	addi	s0,sp,16
	.cfi_def_cfa 8, 0
	li	a0,4
	call	_Z9fibonaccii
	mv	a5,a0
	nop
	mv	a0,a5
	lw	ra,12(sp)
	.cfi_restore 1
	lw	s0,8(sp)
	.cfi_restore 8
	.cfi_def_cfa 2, 16
	addi	sp,sp,16
	.cfi_def_cfa_offset 0
	jr	ra
	.cfi_endproc
.LFE1:
	.size	main, .-main
	.ident	"GCC: (GNU) 9.2.0"
	.section	.note.GNU-stack,"",@progbits
```

下面是经过测试后，满足能运行的要求的最短文段。
```bash
	.globl	main
_Z9fibonaccii:
	addi	sp,sp,-32
	sw	ra,28(sp)
	sw	s0,24(sp)
	addi	s0,sp,32
	sw	a0,-20(s0)
	lw	a4,-20(s0)
	li	a5,1
	beq	a4,a5,.L2
	lw	a5,-20(s0)
	addi	a5,a5,-1
	mv	a0,a5
	call	_Z9fibonaccii
	mv	a4,a0
	lw	a5,-20(s0)
	mul	a5,a4,a5
	j	.L4
.L2:
	lw	a5,-20(s0)
.L4:
	mv	a0,a5
	lw	ra,28(sp)
	lw	s0,24(sp)
	addi	sp,sp,32
	jr	ra
main:
	addi	sp,sp,-16
	sw	ra,12(sp)
	sw	s0,8(sp)
	addi	s0,sp,16
	li	a0,4
	call	_Z9fibonaccii
	mv	a5,a0
	nop
	mv	a0,a5
	lw	ra,12(sp)
	lw	s0,8(sp)
	addi	sp,sp,16
	jr	ra
```

## 关于全局变量
请修改程序并观察输出，观察结果。
```cpp
int k = 8;
int a[4][8] = {1, 2, 3};
int main(){
    return k + a[0][1];
}
```

```bash
	.file	"test.cpp"
	.option nopic
	.text
	.globl	k
	.section	.sdata,"aw"
	.align	2
	.type	k, @object
	.size	k, 4
k:
	.word	8
	.globl	a
	.data
	.align	2
	.type	a, @object
	.size	a, 128
a:
	.word	1
	.word	2
	.word	3
	.zero	20
	.zero	96
	.text
	.align	1
	.globl	main
	.type	main, @function
main:
.LFB0:
	addi	sp,sp,-16
	sw	s0,12(sp)
	addi	s0,sp,16
	lui	a5,%hi(a)
	addi	a5,a5,%lo(a)
	lw	a4,4(a5)
	lui	a5,%hi(k)
	lw	a5,%lo(k)(a5)
	add	a5,a4,a5
	mv	a0,a5
	lw	s0,12(sp)
	addi	sp,sp,16
	jr	ra

```

## 全局变量在函数内被赋值
待补

## 函数形参个数超过寄存器个数
待补
```cpp
int add(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10){
    return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10;
}
int main(){
    return add(1,2,3,4,5,6,7,8,9,10);
}
```

```
	.file	"test.cpp"
	.option nopic
	.text
	.align	1
	.globl	_Z3addiiiiiiiiii
	.type	_Z3addiiiiiiiiii, @function
_Z3addiiiiiiiiii:
.LFB0:
	.cfi_startproc
	addi	sp,sp,-48
	.cfi_def_cfa_offset 48
	sw	s0,44(sp)
	.cfi_offset 8, -4
	addi	s0,sp,48
	.cfi_def_cfa 8, 0
	sw	a0,-20(s0)
	sw	a1,-24(s0)
	sw	a2,-28(s0)
	sw	a3,-32(s0)
	sw	a4,-36(s0)
	sw	a5,-40(s0)
	sw	a6,-44(s0)
	sw	a7,-48(s0)
	lw	a4,-20(s0)
	lw	a5,-24(s0)
	add	a4,a4,a5
	lw	a5,-28(s0)
	add	a4,a4,a5
	lw	a5,-32(s0)
	add	a4,a4,a5
	lw	a5,-36(s0)
	add	a4,a4,a5
	lw	a5,-40(s0)
	add	a4,a4,a5
	lw	a5,-44(s0)
	add	a4,a4,a5
	lw	a5,-48(s0)
	add	a4,a4,a5
	lw	a5,0(s0)
	add	a4,a4,a5
	lw	a5,4(s0)
	add	a5,a4,a5
	mv	a0,a5
	lw	s0,44(sp)
	.cfi_restore 8
	.cfi_def_cfa 2, 48
	addi	sp,sp,48
	.cfi_def_cfa_offset 0
	jr	ra
	.cfi_endproc
.LFE0:
	.size	_Z3addiiiiiiiiii, .-_Z3addiiiiiiiiii
	.align	1
	.globl	main
	.type	main, @function
main:
	addi	sp,sp,-32
	sw	ra,28(sp)
	sw	s0,24(sp)
	addi	s0,sp,32
	li	a5,10
	sw	a5,4(sp)
	li	a5,9
	sw	a5,0(sp)
	li	a7,8
	li	a6,7
	li	a5,6
	li	a4,5
	li	a3,4
	li	a2,3
	li	a1,2
	li	a0,1
	call	_Z3addiiiiiiiiii
	mv	a5,a0
	nop
	mv	a0,a5
	lw	ra,28(sp)
	lw	s0,24(sp)
	addi	sp,sp,32
	jr	ra
.LFE1:
	.size	main, .-main
	.ident	"GCC: (GNU) 9.2.0"
	.section	.note.GNU-stack,"",@progbits

```

通过观察，可以发现:
①当前函数进来后，首先移动sp，sp大小自己确定，然后在原来的sp下面依次放ra和s0
②保存好后，fp（s0）就赋值为sp之前的值，到时候便于返回
③传的参数，在进入函数前，是放在栈指针上面的，按照地址增大的顺序先后放a9, a10...
④如果是临时变量保存在内存，都会以fp为基准去放，但被调用者保存寄存器是看sp去放的。
综上所述，计算帧指针的大小，是一个问题。建议在遍历完instVec后再确定。
有个问题，如果寄存器没有东西的话，是可以不保存的，但ra和fp一定会被保存，sp虽然是callee，但由于往往会记得到偏移量，在开头和结尾都会加回来，所以不用保存（省lw和store的时间）。
一个示例：
```bash
        0xff--->---------------------------
                |          a10            |
                ---------------------------
                |          a9             |
                ---------------------------<----sp_old<--------fp_new
                |          ra             |		
                ---------------------------<-------Here we denote that fp - 4 means area of ra in memory
                |          s0/fp          |        Pay attention to the address direction
                ---------------------------
                |          ....           |
        0x00--->---------------------------<----sp_new

```
注意栈是向下生长的！注意保存的含义是函数进入时保存，退出前恢复！